<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ETH Buy Tables</title>

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">

  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 30px 20px;
      background: #eef2f7;
      color: #222;
    }

    .container {
      max-width: 1050px;
      margin: 0 auto;
      background: #fff;
      padding: 28px 26px;
      border-radius: 14px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.08);
    }

    h1 {
      text-align: center;
      margin-bottom: 26px;
      font-size: 24px;
      font-weight: 700;
    }

    #fetchedInfo {
      text-align: center;
      margin-bottom: 24px;
      font-size: 15px;
      font-weight: 600;
    }

    #currentPriceDisplay,
    #lastBuyDisplay {
      padding: 3px 6px;
      border-radius: 6px;
      background: rgba(0,0,0,0.03);
    }

    .inputs {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 22px;
      margin-bottom: 22px;
      padding: 6px;
    }

    .inputs div { display: flex; flex-direction: column; }

    .inputs label {
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .inputs input {
      padding: 9px 12px;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }

    .inputs input:focus {
      border-color: #007bff;
      outline: 3px solid rgba(0,123,255,0.08);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin: 0 auto;
    }

    th, td {
      border: 1px solid #ddd;
      padding: 8px 4px;
      text-align: center;
      white-space: nowrap;
      min-width: 70px;
      max-width: 110px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    th {
      background: #007bff;
      color: #fff;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 13px;
      letter-spacing: 0.3px;
    }

    tr:nth-child(even) { background: #f8fafc; }
    tr:hover { background: rgba(0,123,255,0.03); }

    .profit { color: #0a9d58; font-weight: 700; }
    .loss   { color: #d93025; font-weight: 700; }

 
    .btn-close {
      padding: 6px 10px;
      font-size: 13px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      transition: 0.14s ease;
    }
    .btn-close:hover { transform: translateY(-1px); opacity: 0.95; }

    .errorMsg { color:#d93025; }
    .successMsg { color:#0a9d58; }
	
 #chartWrap { width:100%; }
  #ethChart { width:100%; height:320px; display:block; }

@media (max-width: 720px) {
  #ethChart { height: 220px; }
}

    @media (max-width: 720px) {
      .inputs { gap: 12px; }
      th, td { padding: 6px 4px; font-size: 13px; } /* FIX: comma removed */
      .btn-close { padding: 6px 8px; }
      .hide-mobile, .col-current, .col-gross, .col-fee { display: none; }
    }
  </style>

<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
</head>
<body>
<div class="container">

<div id="chartWrap" style="margin: 14px 0 18px; border:1px solid #e6edf5; border-radius:12px; overflow:hidden;">
  <div id="ethChart" style="height: 320px; width: 100%;"></div>
</div>

<div style="text-align:center; margin-bottom:18px;">
    <h1>ETH Buy Tables</h1>
    <svg width="60" height="60" viewBox="0 0 60 60">
      <circle id="refreshRingBg" cx="30" cy="30" r="26" fill="none" stroke-width="5" stroke="#d6dce3" />
      <circle
        id="refreshRing"
        cx="30" cy="30" r="26"
        fill="none" stroke-width="5"
        stroke="#007bff"
        stroke-linecap="round"
        stroke-dasharray="163.36"
        stroke-dashoffset="0"
        transform="rotate(-90 30 30)"
      />
      <text id="refreshTimeText" x="30" y="35" font-size="16" text-anchor="middle" fill="#333" font-weight="600">5</text>
    </svg>
    <div style="margin-top:6px; font-weight:600; color:#444; font-size:13px;">
      Refreshing in <span id="refreshText">5</span>s
    </div>
  </div>

  <div id="statusMsg" style="text-align:center; margin:10px 0; font-weight:600; color:#007bff;"></div>

  <div id="fetchedInfo">
    ETH Price: <span id="currentPriceDisplay">-</span> &nbsp; | &nbsp;
    Nearest Buy order: <span id="lastBuyDisplay">-</span> &nbsp; | &nbsp;
    Available : <span id="usdtBalance">-</span> &nbsp; | &nbsp;
    Error: <span id="jasonerror">-</span>
  </div>

  <div class="inputs">
    <div>
      <label>Start Price</label>
      <input id="startPrice" type="number">
    </div>
    <div>
      <label>End Price</label>
      <input id="endPrice" type="number">
    </div>
    <div>
      <label>Price Step (USD)</label>
      <input id="step" type="number">
    </div>
    <div>
      <label>Lot Size (ETH)</label>
      <input id="lotSize" type="number" step="0.0001">
    </div>
    <div>
      <label>Nearest Buy (editable)</label>
      <input id="lastBuy" type="number">
    </div>
  </div>

  <div class="table-wrapper">
    <table id="buyTable">
      <thead>
        <tr>
          <th>Price</th>
          <th>ETH</th>
          <th>Cost</th>
          <th class="hide-mobile">Current Value</th>
          <th class="hide-mobile">Gross P/L</th>
          <th class="hide-mobile">Fee 0.2%</th>
          <th>PnL</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

</div>

<script>
/* ===================== CONFIG ===================== */
const defaultValues = {
  startPrice: 5000,
  endPrice: 2520,
  step: 20,
  lotSize: 0.12,
  lastBuy: 0
};

const feeRate = 0.002;
const PROFIT_ALERT_THRESHOLD = 2;

/* ===================== CHART ===================== */
let chart, candleSeries;
let buyLineRefs = [];
let _lastCandleTime = 0;

function initChart() {
  const el = document.getElementById('ethChart');

  // container must have real size
  const w = el.clientWidth || 800;
  const h = el.clientHeight || 320;

  chart = LightweightCharts.createChart(el, {
    width: w,
    height: h,

    layout: { background: { type: 'solid', color: '#ffffff' }, textColor: '#222' },
    grid: { vertLines: { color: '#eef2f7' }, horzLines: { color: '#eef2f7' } },
    rightPriceScale: { borderColor: '#e6edf5' },
    timeScale: { borderColor: '#e6edf5', timeVisible: true, secondsVisible: false },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
  });

  const candleOpts = {
    upColor: '#0a9d58',
    downColor: '#d93025',
    borderUpColor: '#0a9d58',
    borderDownColor: '#d93025',
    wickUpColor: '#0a9d58',
    wickDownColor: '#d93025',
  };

  if (typeof chart.addCandlestickSeries === "function") {
    candleSeries = chart.addCandlestickSeries(candleOpts);
  } else {
    candleSeries = chart.addSeries(LightweightCharts.CandlestickSeries, candleOpts);
  }

  // resize: update BOTH width & height
  const ro = new ResizeObserver(() => {
    const nw = el.clientWidth;
    const nh = el.clientHeight;
    chart.applyOptions({ width: nw, height: nh });
    chart.timeScale().fitContent();
  });
  ro.observe(el);
}


async function fetchCandles(interval = '5m', limit = 200) {
  // Binance Klines
  const url = `https://api.binance.com/api/v3/klines?symbol=ETHUSDT&interval=${interval}&limit=${limit}`;
  const resp = await fetch(url, { cache: "no-store" });
  if (!resp.ok) throw new Error('Candles fetch failed');
  const raw = await resp.json();

  return raw.map(k => ({
    time: Math.floor(k[0] / 1000),
    open: parseFloat(k[1]),
    high: parseFloat(k[2]),
    low:  parseFloat(k[3]),
    close:parseFloat(k[4]),
  }));
}

async function loadChartOnce() {
  if (!chart) initChart();
  const candles = await fetchCandles('15m', 250);
  candleSeries.setData(candles);

  _lastCandleTime = candles.length ? candles[candles.length - 1].time : 0;

  // fit nicely
  chart.timeScale().fitContent();
}

function clearBuyLines() {
  buyLineRefs.forEach(line => candleSeries.removePriceLine(line));
  buyLineRefs = [];
}

function getBuyPricesFromInputs() {
  const start = parseFloat(document.getElementById('startPrice').value) || defaultValues.startPrice;
  const end   = parseFloat(document.getElementById('endPrice').value)   || defaultValues.endPrice;
  const step  = Math.abs(parseFloat(document.getElementById('step').value) || defaultValues.step);
  const lastBuy = parseFloat(document.getElementById('lastBuy').value)  || defaultValues.lastBuy;

  const buys = [];
  for (let p = start; p >= end; p -= step) buys.push(p);
  buys.reverse();

  // same rule as your table: only show rows where buyPrice > lastBuy
  return buys.filter(p => p > lastBuy);
}

function drawBuyLimitLines() {
  if (!candleSeries) return;

  clearBuyLines();

  const buyPrices = getBuyPricesFromInputs().slice(-20);
  buyPrices.forEach((price) => {
    const line = candleSeries.createPriceLine({
      price,
      color: 'rgba(0,123,255,0.55)',
      lineWidth: 1,
      lineStyle: LightweightCharts.LineStyle.Solid,
      axisLabelVisible: true,
      title: `BUY ${price.toFixed(0)}`,
      autoScale: false,   // âœ… IMPORTANT: stops chart from shrinking
    });
    buyLineRefs.push(line);
  });
}


let marketLineRef = null;
function drawMarketPriceLine(currentPrice) {
  if (!candleSeries || !currentPrice) return;

  if (marketLineRef) candleSeries.removePriceLine(marketLineRef);

  marketLineRef = candleSeries.createPriceLine({
    price: currentPrice,
    color: 'rgba(0,0,0,0.45)',
    lineWidth: 1,
    lineStyle: LightweightCharts.LineStyle.Dashed,
    axisLabelVisible: true,
    title: `MKT ${parseFloat(currentPrice).toFixed(2)}`,
    autoScale: false,   // âœ… IMPORTANT
  });
}



/* ===================== COUNTDOWN UI VARS (MUST BE FIRST) ===================== */
const refreshIntervalSec = 5;
let refreshRemaining = refreshIntervalSec;

const ring = document.getElementById('refreshRing');
const t1   = document.getElementById('refreshTimeText');
const t2   = document.getElementById('refreshText');

const circumference = 2 * Math.PI * 26;
ring.setAttribute('stroke-dasharray', circumference.toFixed(2));

/* ===================== INPUTS PERSIST ===================== */
function loadInputs() {
  for (const key in defaultValues) {
    const input = document.getElementById(key);
    const saved = localStorage.getItem(key);
    input.value = saved !== null ? saved : defaultValues[key];

    input.addEventListener('input', () => {
      localStorage.setItem(key, input.value);
      safeRefresh();
    });
  }
}

/* ===================== FETCH PRICE (PUBLIC) ===================== */
async function fetchCurrentPrice() {
  try {
    const resp = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT', { cache: "no-store" });
    if (!resp.ok) throw new Error('Price fetch failed');
    const data = await resp.json();
    const price = parseFloat(data.price);
    document.getElementById('currentPriceDisplay').textContent = price.toFixed(2);
    return price;
  } catch (err) {
    console.error('fetchCurrentPrice error', err);
    document.getElementById('currentPriceDisplay').textContent = '-';
    return parseFloat(document.getElementById('lastBuy').value || defaultValues.lastBuy) || 0;
  }
}

/* ===================== FETCH NEAREST BUY (SERVER) ===================== */
async function fetchNearestBuy() {
  try {
    const resp = await fetch('getNearestBuy.php', { cache: "no-store" });
    if (!resp.ok) throw new Error('Nearest-buy fetch failed');
    const data = await resp.json();

    const lastBuyInput = document.getElementById('lastBuy');

    // If your PHP returns error like: {status:"error", msg:"...", binanceResponse:{...}}
    if (data.status === "error") {
      document.getElementById('jasonerror').textContent = data.msg || 'Server error';
      console.error("Binance detail:", data.binanceResponse || data);
      document.getElementById('lastBuyDisplay').textContent = lastBuyInput.value || '-';
      return {
        nearestBuy: parseFloat(lastBuyInput.value || 0),
        currentPrice: data.currentPrice ? parseFloat(data.currentPrice) : null
      };
    } else {
      document.getElementById('jasonerror').textContent = '-';
    }

    if (data.nearestBuyPrice && parseFloat(data.nearestBuyPrice) > 0) {
      lastBuyInput.value = parseFloat(data.nearestBuyPrice).toFixed(2);
      localStorage.setItem('lastBuy', lastBuyInput.value);
    }

    document.getElementById('lastBuyDisplay').textContent = lastBuyInput.value || '-';

    return {
      nearestBuy: parseFloat(lastBuyInput.value || 0),
      currentPrice: data.currentPrice ? parseFloat(data.currentPrice) : null
    };

  } catch (err) {
    console.error('fetchNearestBuy error', err);
    document.getElementById('lastBuyDisplay').textContent = document.getElementById('lastBuy').value || '-';
    document.getElementById('jasonerror').textContent = String(err);
    return {
      nearestBuy: parseFloat(document.getElementById('lastBuy').value || 0),
      currentPrice: null
    };
  }
}

/* ===================== FETCH BALANCE ===================== */
async function fetchBalance() {
  try {
    const resp = await fetch('getBalance.php', { cache: 'no-store' });
    const data = await resp.json();
    const bal = parseFloat(data.freeUSDT ?? 0) || 0;
    document.getElementById('usdtBalance').textContent = bal.toFixed(2) + ' USDT';
    return bal;
  } catch (e) {
    console.error("Balance fetch error", e);
    document.getElementById('usdtBalance').textContent = '-';
    return 0;
  }
}

/* ===================== TABLE BUILDER ===================== */
let _blinkState = false;
let _soundPlayed = false;
const alertSound = new Audio("data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQQAAAAA");

function buildTable(currentPrice) {
  let lastPositiveNet = null;
  let hasNegative = false;

  const start = parseFloat(document.getElementById('startPrice').value) || defaultValues.startPrice;
  const end   = parseFloat(document.getElementById('endPrice').value)   || defaultValues.endPrice;
  const step  = Math.abs(parseFloat(document.getElementById('step').value) || defaultValues.step);
  const lot   = parseFloat(document.getElementById('lotSize').value)    || defaultValues.lotSize;
  const lastBuy = parseFloat(document.getElementById('lastBuy').value)  || defaultValues.lastBuy;

  const tbody = document.querySelector('#buyTable tbody');
  tbody.innerHTML = '';

  const buys = [];
  for (let p = start; p >= end; p -= step) buys.push(p);
  buys.reverse();

  buys.forEach(buyPrice => {
    const showPnl = buyPrice > lastBuy;
    if (!showPnl) return; // skip rows without PnL

    const cost = lot * buyPrice;
    const currentValue = lot * currentPrice;
    const gross = currentValue - cost;
    const fee   = cost * feeRate;
    const net   = gross - fee;

    if (net > 0) lastPositiveNet = net;
    if (net < 0) hasNegative = true;

    const tr = document.createElement('tr');

    const tdPrice = document.createElement('td'); tdPrice.textContent = buyPrice.toFixed(2);
    const tdEth   = document.createElement('td'); tdEth.textContent = lot.toFixed(4);
    const tdCost  = document.createElement('td'); tdCost.textContent = cost.toFixed(2);

    const tdCur   = document.createElement('td'); tdCur.textContent = currentValue.toFixed(2);
    tdCur.className = "col-current";

    const tdGross = document.createElement('td'); tdGross.textContent = gross.toFixed(2);
    tdGross.className = (gross >= 0 ? "profit " : "loss ") + "col-gross";

    const tdFee   = document.createElement('td'); tdFee.textContent = fee.toFixed(2);
    tdFee.className = "col-fee";

    const tdNet = document.createElement('td'); tdNet.textContent = net.toFixed(2);
    tdNet.className = net >= 0 ? 'profit' : 'loss';

    const tdAction = document.createElement('td');
    if (net > 0) {
      const btn = document.createElement('button');
      btn.className = 'btn-close';
      btn.textContent = 'Close';
      btn.addEventListener('click', () => closeAndRebuy(buyPrice, lot, btn));
      tdAction.appendChild(btn);
    }

    tr.append(tdPrice, tdEth, tdCost, tdCur, tdGross, tdFee, tdNet, tdAction);
    tbody.appendChild(tr);
  });

  // TAB TITLE LOGIC
  if (lastPositiveNet !== null) {
    if (lastPositiveNet >= PROFIT_ALERT_THRESHOLD) {
      _blinkState = !_blinkState;
      document.title = _blinkState
        ? `+${lastPositiveNet.toFixed(2)} USDT | ETH Buy Tables`
        : `ðŸ’° PROFIT ALERT ðŸ’°`;

      if (!_soundPlayed) {
        alertSound.play().catch(() => {});
        _soundPlayed = true;
      }
    } else {
      document.title = `+${lastPositiveNet.toFixed(2)} USDT | ETH Buy Tables`;
      _soundPlayed = false;
    }
  } else if (hasNegative) {
    document.title = `ðŸ”´ LOSS | ETH Buy Tables`;
    _soundPlayed = false;
  } else {
    document.title = 'ETH Buy Tables';
    _soundPlayed = false;
  }
}

/* ===================== TRADE ACTION ===================== */
async function closeAndRebuy(price, eth, btn) {
  const msgBox = document.getElementById("statusMsg");
  msgBox.className = "";
  msgBox.textContent = `Submitting SELL market and BUY limit for ${eth} ETH at ${price.toFixed(2)} USD`;

  btn.disabled = true;
  const originalText = btn.textContent;
  btn.textContent = "Processing...";

  try {
    const form = new FormData();
    form.append("price", price);
    form.append("lot", eth);

    const resp = await fetch("tradeAction.php", { method: "POST", body: form });
    const data = await resp.json();

    if (data.status === "success") {
      msgBox.textContent = `Orders submitted successfully for ${eth} ETH at ${price.toFixed(2)} USD`;
      msgBox.className = "successMsg";
      await safeRefresh();
    } else {
      console.error("Trade error:", data.binanceResponse || data);
      msgBox.textContent = `Trade submission failed for ${eth} ETH`;
      msgBox.className = "errorMsg";
    }
  } catch (err) {
    console.error("Fetch exception:", err);
    msgBox.textContent = `Network error while submitting trade`;
    msgBox.className = "errorMsg";
  } finally {
    btn.disabled = false;
    btn.textContent = originalText;
  }
}

/* ===================== SAFE REFRESH ===================== */
let _refreshRunning = false;
async function safeRefresh() {
  if (_refreshRunning) return;
  _refreshRunning = true;

  try {
    const nearest = await fetchNearestBuy();
    let currentPrice = nearest.currentPrice;

    if (!currentPrice || currentPrice === 0) {
      currentPrice = await fetchCurrentPrice();
    } else {
      document.getElementById('currentPriceDisplay').textContent = parseFloat(currentPrice).toFixed(2);
    }

    await fetchBalance();

    buildTable(currentPrice);

    // update chart overlays
    drawBuyLimitLines();
    drawMarketPriceLine(currentPrice);

  } finally {
    _refreshRunning = false;
  }
}

/* ===================== COUNTDOWN LOOP ===================== */
setInterval(async () => {
  refreshRemaining -= 0.1;
  if (refreshRemaining <= 0) refreshRemaining = 0;

  const sec = Math.ceil(refreshRemaining);
  t1.textContent = sec;
  t2.textContent = sec;

  const progress = 1 - (refreshRemaining / refreshIntervalSec);
  const offset = circumference * (1 - progress);
  ring.setAttribute('stroke-dashoffset', offset.toFixed(2));

  if (refreshRemaining === 0) {
    await safeRefresh();
    refreshRemaining = refreshIntervalSec;
  }
}, 100);


/* ===================== INIT ===================== */
loadInputs();

loadChartOnce()
  .then(() => safeRefresh())
  .catch(err => {
    console.error("Chart init error:", err);
    // chart fail ho bhi jaye, table still works
    safeRefresh();
  });

</script>
</body>
</html>
