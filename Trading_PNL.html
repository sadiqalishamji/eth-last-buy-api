<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ETH Buy Table</title>
  <style>
    /* Base Layout */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 30px 20px;
      background: #eef2f7;
      color: #222;
    }

    .container {
      max-width: 1050px;
      margin: 0 auto;
      background: #fff;
      padding: 28px 26px;
      border-radius: 14px;
      box-shadow: 0 8px 18px rgba(0,0,0,0.08);
    }

    h1 {
      text-align: center;
      margin-bottom: 26px;
      font-size: 24px;
      font-weight: 700;
    }

    /* API Info Display */
    #fetchedInfo {
      text-align: center;
      margin-bottom: 24px;
      font-size: 15px;
      font-weight: 600;
    }

    #currentPriceDisplay,
    #lastBuyDisplay {
      padding: 3px 6px;
      border-radius: 6px;
      background: rgba(0,0,0,0.03);
    }

    /* Inputs Panel */
    .inputs {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 22px;
      margin-bottom: 22px;
      padding: 6px;
    }

    .inputs div {
      display: flex;
      flex-direction: column;
    }

    .inputs label {
      font-weight: 600;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .inputs input {
      padding: 9px 12px;
      font-size: 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
    }

    .inputs input:focus {
      border-color: #007bff;
      outline: 3px solid rgba(0,123,255,0.08);
    }

    /* Table Styles */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
      margin-top: 10px;
    }

    th, td {
      border: 1px solid #e6e9ee;
      padding: 12px 8px;
      vertical-align: middle;
    }

    th {
      background: #007bff;
      color: #fff;
      font-weight: 600;
      text-transform: uppercase;
      font-size: 13px;
      letter-spacing: 0.3px;
    }

    tr:nth-child(even) {
      background: #f8fafc;
    }

    tr:hover {
      background: rgba(0,123,255,0.03);
    }

    /* Profit/Loss Coloring */
    .profit {
      color: #0a9d58; /* Green */
      font-weight: 700;
    }

    .loss {
      color: #d93025; /* Red */
      font-weight: 700;
    }

    /* Close Button */
    .btn-close {
      padding: 6px 10px;
      font-size: 13px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      transition: 0.14s ease;
    }
    .btn-close:hover { transform: translateY(-1px); opacity: 0.95; }

    /* Small screens */
    @media (max-width: 720px) {
      .inputs { gap: 12px; }
      th, td { padding: 8px; font-size: 13px; }
      .btn-close { padding: 6px 8px; }
    }

  </style>
</head>
<body>

<div class="container">
  <h1>ETH Buy Table</h1>

  <!-- API Fetch Confirmation Panel -->
  <div id="fetchedInfo">
    ETH Price: <span id="currentPriceDisplay">-</span> USD &nbsp; | &nbsp;
    Nearest Buy order: <span id="lastBuyDisplay">-</span> USD
    Available (isolated): <span id="usdtBalance">-</span> USD
  </div>

  <!-- Inputs -->
  <div class="inputs">
    <div>
      <label>Start Price</label>
      <input id="startPrice" type="number">
    </div>
    <div>
      <label>End Price</label>
      <input id="endPrice" type="number">
    </div>
    <div>
      <label>Price Step (USD)</label>
      <input id="step" type="number">
    </div>
    <div>
      <label>Lot Size (ETH)</label>
      <input id="lotSize" type="number" step="0.0001">
    </div>
    <div>
      <label>Nearest Buy (editable)</label>
      <input id="lastBuy" type="number">
    </div>
  </div>

  <!-- Table -->
  <table id="buyTable" aria-live="polite">
    <thead>
      <tr>
        <th>Buy Price</th>
        <th>ETH Bought</th>
        <th>Cost (USD)</th>
        <th>Current Value</th>
        <th>Gross P/L</th>
        <th>Fee 0.2%</th>
        <th>Net P/L</th>
        <th>Action</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<script>
/* ====== Defaults & Inputs Persistence ====== */
const defaultValues = {
  startPrice: 5000,
  endPrice: 2520,
  step: 20,
  lotSize: 0.12,
  lastBuy: 2940
};

function loadInputs() {
  for (const key in defaultValues) {
    const input = document.getElementById(key);
    const saved = localStorage.getItem(key);
    input.value = saved !== null ? saved : defaultValues[key];
    input.addEventListener('input', () => {
      localStorage.setItem(key, input.value);
      // Rebuild immediately for instant feedback
      safeRefresh();
    });
  }
}

/* ====== Fetch Current Price (public endpoint) ====== */
async function fetchCurrentPrice() {
  try {
    const resp = await fetch('https://api.binance.com/api/v3/ticker/price?symbol=ETHUSDT', {cache: "no-store"});
    if (!resp.ok) throw new Error('Price fetch failed');
    const data = await resp.json();
    const price = parseFloat(data.price);
    document.getElementById('currentPriceDisplay').textContent = price.toFixed(2);
    return price;
  } catch (err) {
    console.error('fetchCurrentPrice error', err);
    document.getElementById('currentPriceDisplay').textContent = '-';
    return parseFloat(defaultValues.lastBuy); // fallback so UI doesn't break
  }
}

/* ====== Fetch nearest isolated LIMIT buy via server-side API (Render) ====== */
async function fetchNearestBuy() {
  try {
    const resp = await fetch('getNearestBuy.php', {cache: "no-store"});
    if (!resp.ok) throw new Error('Nearest-buy fetch failed');
    const data = await resp.json();
    const lastBuyInput = document.getElementById('lastBuy');

    if (data.nearestBuyPrice && parseFloat(data.nearestBuyPrice) > 0) {
      lastBuyInput.value = parseFloat(data.nearestBuyPrice).toFixed(2);
      localStorage.setItem('lastBuy', lastBuyInput.value);
    }
    // update display fields
    document.getElementById('lastBuyDisplay').textContent = lastBuyInput.value || '-';
    if (data.currentPrice) {
      document.getElementById('currentPriceDisplay').textContent = parseFloat(data.currentPrice).toFixed(2);
    }
    return { nearestBuy: parseFloat(lastBuyInput.value || 0), currentPrice: parseFloat(data.currentPrice || 0) };
  } catch (err) {
    console.error('fetchNearestBuy error', err);
    document.getElementById('lastBuyDisplay').textContent = document.getElementById('lastBuy').value || '-';
    return { nearestBuy: parseFloat(document.getElementById('lastBuy').value || 0), currentPrice: null };
  }
}

/* ====== Core Table Builder ====== */
function buildTable(currentPrice) {
  // ensure numbers
  const start = parseFloat(document.getElementById('startPrice').value) || defaultValues.startPrice;
  const end   = parseFloat(document.getElementById('endPrice').value) || defaultValues.endPrice;
  const step  = Math.abs(parseFloat(document.getElementById('step').value) || defaultValues.step);
  const lot   = parseFloat(document.getElementById('lotSize').value) || defaultValues.lotSize;
  const lastBuy = parseFloat(document.getElementById('lastBuy').value) || defaultValues.lastBuy;

  const tbody = document.querySelector('#buyTable tbody');
  tbody.innerHTML = '';

  const feeRate = 0.002;
  const buys = [];
  for (let p = start; p >= end; p -= step) buys.push(p);
  buys.reverse(); // inverted so earliest buy at bottom

  buys.forEach(buyPrice => {
    const cost = lot * buyPrice;
    const currentValue = lot * currentPrice;
    const gross = currentValue - cost;
    const fee   = cost * feeRate;
    const net   = gross - fee;
    const showPnl = buyPrice > lastBuy; // PNL only shown for buys >= selected threshold

    const tr = document.createElement('tr');

    // Create cells
    const tdPrice = document.createElement('td'); tdPrice.textContent = buyPrice.toFixed(2);
    const tdEth   = document.createElement('td'); tdEth.textContent = lot.toFixed(4);
    const tdCost  = document.createElement('td'); tdCost.textContent = cost.toFixed(2);
    const tdCur   = document.createElement('td'); tdCur.textContent = currentValue.toFixed(2);

    const tdGross = document.createElement('td');
    tdGross.textContent = showPnl ? gross.toFixed(2) : '';
    if (showPnl) tdGross.className = gross >= 0 ? 'profit' : 'loss';

    const tdFee = document.createElement('td');
    tdFee.textContent = showPnl ? fee.toFixed(2) : '';

    const tdNet = document.createElement('td');
    tdNet.textContent = showPnl ? net.toFixed(2) : '';
    if (showPnl) tdNet.className = net >= 0 ? 'profit' : 'loss';

    // Action column
    const tdAction = document.createElement('td');
    if (showPnl && net > 0) {
      const btn = document.createElement('button');
      btn.className = 'btn-close';
      btn.textContent = 'Close';
      btn.title = `Sell ${lot} ETH (market) and place limit buy at ${buyPrice.toFixed(2)}`;
      btn.addEventListener('click', () => closeAndRebuy(buyPrice, lot, btn));
      tdAction.appendChild(btn);
    } else {
      tdAction.textContent = '';
    }

    // Append all tds
    tr.appendChild(tdPrice);
    tr.appendChild(tdEth);
    tr.appendChild(tdCost);
    tr.appendChild(tdCur);
    tr.appendChild(tdGross);
    tr.appendChild(tdFee);
    tr.appendChild(tdNet);
    tr.appendChild(tdAction);

    tbody.appendChild(tr);
  });
}

/* ====== Close & Re-buy action (POST to server-side tradeAction.php) ====== */
async function closeAndRebuy(price, eth, btn) {
  if (!confirm(`Close ${eth} ETH at market and place buy limit at ${price.toFixed(2)}?`)) return;
  try {
    btn.disabled = true;
    btn.textContent = 'Processing...';

    const form = new FormData();
    form.append('price', price);
    form.append('lot', eth);

    const resp = await fetch('tradeAction.php', {
      method: 'POST',
      body: form
    });
    const data = await resp.json();

    if (data.status === 'success') {
      alert('Market sell and limit buy placed successfully.');
      // refresh to reflect changes
      await safeRefresh();
    } else {
      console.error('tradeAction error', data);
      alert('Trade failed: ' + (data.msg || JSON.stringify(data)));
    }
  } catch (err) {
    console.error('closeAndRebuy exception', err);
    alert('Request error: ' + err.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Close';
  }
}

/* ====== Fetch Balance of available usdt in isolated wallet ====== */
async function fetchBalance() {
  try {
    const resp = await fetch('getBalance.php');
    const data = await resp.json();
    const bal = data.freeUSDT ?? 0;
    // update some DOM element
    document.getElementById('usdtBalance').textContent = bal.toFixed(2) + ' USDT';
    return bal;
  } catch (e) {
    console.error("Balance fetch error", e);
    return 0;
  }
}


/* ====== Refresh logic (safe with fallbacks) ====== */
let _refreshRunning = false;
async function safeRefresh() {
  if (_refreshRunning) return; // avoid overlapping refreshes
  _refreshRunning = true;
  try {
    // prefer server-provided nearest buy which includes current price
    const nearest = await fetchNearestBuy(); // returns {nearestBuy, currentPrice}
    let currentPrice = nearest.currentPrice;
    if (!currentPrice || currentPrice === 0) {
      // fallback to public price
      currentPrice = await fetchCurrentPrice();
    } else {
      // ensure UI shows the fetched current price
      document.getElementById('currentPriceDisplay').textContent = parseFloat(currentPrice).toFixed(2);
    }

    const usdtFree = await fetchBalance();  // updates UI element

    buildTable(currentPrice);
  } finally {
    _refreshRunning = false;
  }
}

/* ====== Initialization ====== */
loadInputs();
safeRefresh();
setInterval(safeRefresh, 5000); // refresh every 5 seconds

</script>

</body>
</html>
